//Copyright 2020-2023 Kenneth Claassen. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "AnimNode_MotionRecorder.h"
#include "Animation/AnimNodeBase.h"
#include "Animation/AnimNode_AssetPlayerBase.h"
#include "Objects/Assets/MotionCalibration.h"
#include "Objects/Assets/MotionDataAsset.h"
#include "Data/AnimChannelState.h"
#include "Data/PoseMotionData.h"
#include "Data/Trajectory.h"
#include "Enumerations/EMotionMatchingEnums.h"
#include "AnimNode_MSMotionMatching.generated.h"

struct FDistanceMatchPayload;
struct FMotionActionPayload;
struct FMotionTraitField;

/** An animation node which performs motion matching to synthesise animation. It is an asset player
which uses MotionAnimData asset as it's source data. The node can be used with inertialization and 
also the pose snapshot node which is also a part of Motion Symphony. */
USTRUCT(BlueprintInternalUseOnly) 
struct MOTIONSYMPHONY_API FAnimNode_MSMotionMatching : public FAnimNode_AssetPlayerBase
{
	GENERATED_BODY()

public:
	/** The desired trajectory of the character. This is the primary input and must be generated via a 'Trajectory Generator' 
	component on the character. Past trajectory is recorded from historical character positions and future trajectory is 
	predicted using a movement model over several iterations. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Input", meta = (PinShownByDefault))
	FMotionMatchingInputData InputData;
	
	/** Motion Matching searches only occur every 'Update Interval'. This input allows the suer to force a motion matching
	 * update for the purposes of improve responsiveness. This is best done when there is a sudden change in user input
	 * where a high level of responsiveness would be desired. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Input", meta = (PinHiddenByDefault))
	bool bUserForcePoseSearch;

	/** The time interval between motion matching updates. This is not the frame rate or the rate at which the pose is 
	updated. Instead this is merely the rate at which pose searches are performed on the motion matching database. Keeping
	this value around 0.1 is good for performance as the search will only be done every few frames and higher update rates
	do not necessarily provide better quality. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "General", meta = (PinHiddenByDefault, ClampMin = 0.0f))
	float UpdateInterval;

	/** The time tolerance (in seconds) for another pose to be considered at the same location in the animation database.
	 * This is used when performing a pose search. If the poses are considered to be at the same location or so close that
	 * they are within this tolerance, then there will be no pose transition and the current animation can just keep playing.
	 * This allows for smoother animation. Default value of 0.25 is recommended as a starting point.*/
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "General", meta = (PinHiddenByDefault, ClampMin = 0.0f, ClampMax = 0.5f))
	float SamePoseTolerance = 0.25f;

	/** The playback speed of animations generated by this node.*/
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "General", meta = (PinHiddenByDefault, ClampMin = 0.0f))
	float PlaybackRate;

	/** The blend time between animation changes. This time should ideally be very small (0.2 - 0.3s) so as to avoid
	muddy animation. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "General", meta = (PinHiddenByDefault, ClampMin = 0.0f))
	float BlendTime;

	/** This ratio is used to alter calibration of pose vs. trajectory at runtime. The calibration has it's own pose-trajectory
	 * ratio which is fixed following pre-processing. However, this override multiplier will also be applied for runtime
	 * adjustments. Please note that this setting is very sensitive and should be used carefully. Normal setting of 0.5f will
	 * not affect the motion matching. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "General", meta = (PinHiddenByDefault, ClampMin = 0.0f, ClampMax = 1.0f))
	float OverrideQualityVsResponsivenessRatio;
	
	/** The source pose database for motion matching. This asset must be created and configured in your project and
	referenced here. */
	UPROPERTY(EditAnywhere, Category = "Animation Data", meta = (PinShownByDefault))
	TObjectPtr<UMotionDataAsset> MotionData = nullptr;

	/** Reference to the calibration asset for motion matching. This is a modular asset which can be created and 
	configured in you project. It will use to control weightings for motion matching aspects that affect the 
	selection and synthesis of animation poses. */
	UPROPERTY(EditAnywhere, Category = "Animation Data", meta = (PinShownByDefault))
	TObjectPtr<UMotionCalibration> UserCalibration = nullptr;
	
	UPROPERTY()
	TArray<FCalibrationData> FinalCalibrationSets;

	/** There are two options for pose searches, performance mode and quality mode. Performance mode still gets good
	 results, however, the quality mode performs additional calculations which slightly improve the quality at a
	 small performance cost. Quality mode is 'experimental' and requires the last two 'Match Features' in your
	 Motion Config to be of type 'Bone Location & Velocity'*/
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Options", meta = (PinShownByDefault))
	EMotionMatchingSearchQuality SearchQuality = EMotionMatchingSearchQuality::Performance;

	/** The method of transitioning between animations. This could either be instant, blended or inertialized. Inertialization is
	the recommended method of blending with motion matching for both performance and quality. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Options")
	ETransitionMethod TransitionMethod;

	/** This is the method for handling the past trajectory. It can either be recorded (history) or it can be taken from the 
	current pose. The latter option is preferable if you are using procedural motion a lot but may cause other issues. Please try 
	both options and see what works best for you. (Note: Root motion users should use history) */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Options", meta = (PinHiddenByDefault))
	EPastTrajectoryMode PastTrajectoryMode;

	/** If true, the desired will be blended with the current trajectory with a time falloff. This provides a very realistic 
	trajectory but it can also reduce responsiveness. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Input Response")
	bool bBlendInputResponse;

	/** The total amount of blending allowed by trajectory blending. This is a value between 0 and 1, where 1 is fully blended and
	0 is no blending. By using this value you can strike a balance in trajectory blending between quality and responsiveness. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Input Response", meta = (ClampMin = 0.0f, ClampMax = 1.0f))
	float InputResponseBlendMagnitude;

	/** If true, the current pose will be favoured by the 'CurrentPoseFavour' factor. This can help reduce the number of 'jumps' 
	in motion matching to allow for smooth consistent animation when it is appropriate. Note that excessive use of this feature
	can lead to un-responsive animation. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Pose Favour")
	bool bFavourCurrentPose;

	/** The cost multiplier for favouring the current pose to be used in conjunction with 'FavourCurrentPose' option. 
	The value is a cost multiplier to the pose cost so a value of 1 is no change, lower values make the pose more favoured,
	while higher values make the pose less favourable. */
	UPROPERTY(EditAnywhere, Category = "Pose Favour", meta = (PinHiddenByDefault, ClampMin = 0.0f))
	float CurrentPoseFavour;

	/** A Next Natural is a portion of animation that naturally comes next in an animation sequence. The next natural poses
	 * will always be searched first before the entire database. Additionally any poses marked as 'Next Natural Only' will
	 * not be included in the pose database and the only way they can be chosen is if they are a next natural. This float
	 * determines how far in the future a next natural pose should be considered. */
	UPROPERTY(EditAnywhere, Category = "Next Natural", meta =(PinHiddenByDefault, ClampMin = 0.0f))
	float NextNaturalRange;

	/** If True then the tolerance test will apply to next naturals. If they are 'close enough' the standard pose search
	 * will be cancelled. */
	UPROPERTY(EditAnywhere, Category = "Next Natural")
	bool bNextNaturalToleranceTest;

	/** If true, then a favour multiplier will be applied to the cost of all 'next natural' poses searched*/
	UPROPERTY(EditAnywhere, Category = "Next Natural")
	bool bFavourNextNatural;

	/** The favour multiplier for next naturals when favouring next naturals.*/
	UPROPERTY(EditAnywhere, Category = "Next Natural", meta = (PinHiddenByDefault, ClampMin = 0.05f))
	float NextNaturalFavour;

	/** The next pose tolerance test is a performance check to see if the 'next pose' in the database is good enough. If
	so then the pose search will be cancelled and the current animation will keep playing. It is recommended to always use
	this as it will often trigger when the cahracter is moving straight and save a lot of performance. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Pose Tolerance Test")
	bool bEnableToleranceTest;

	/** Position tolerance for the 'ToleranceTest'. When the pose tolerance test is performed it checks that the trajectory
	of th next pose does not differ from the desired trajectory more than this position threshold. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Pose Tolerance Test", meta = (ClampMin = 0.0f))
	float PositionTolerance;

	/** Rotational (or facing) tolerance for the 'ToleranceTest'. When the pose tolerance test is performed it checks 
	that the trajectory	of th next pose does not differ from the desired trajectory more than this rotation threshold. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Pose Tolerance Test", meta = (ClampMin = 0.0f))
	float RotationTolerance;

	/** The traits that are currently required. This is an important dynamic input into the node and can be used to 
	control which part of the animation database to search. Traits can be set for certain animation sections in the 
	MotionAnimData asset. Only poses with the RequiredTraits will be searched.*/
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Traits", meta = (PinHiddenByDefault))
	FGameplayTagContainer RequiredMotionTags;
	
	int32 CurrentActionId;
	float CurrentActionTime;
	float CurrentActionEndTime;

private:
	float TimeSinceMotionUpdate;
	float TimeSinceMotionChosen;
	float PoseInterpolationValue;
	bool bForcePoseSearch;
	int32 CurrentChosenPoseId;
	int32 InputArraySize;
	int32 MotionRecorderConfigIndex;

	bool bValidToEvaluate;
	bool bInitialized;
	bool bTriggerTransition;

	FPoseMotionData CurrentInterpolatedPose;
	TArray<float> CurrentInterpolatedPoseArray;
	TArray<float> CalibrationArray;
	FAnimChannelState MMAnimState;
	
	//Compact pose format of mirror bone map
	TCustomBoneIndexArray<FCompactPoseBoneIndex, FCompactPoseBoneIndex> CompactPoseMirrorBones;

	//Pre-calculated component space to reference pose, which allows mirror to work with any joint orientation
	TCustomBoneIndexArray<FQuat, FCompactPoseBoneIndex> ComponentSpaceRefRotations;
	
	FAnimInstanceProxy* AnimInstanceProxy; //For Debug drawing
	
#if WITH_EDITORONLY_DATA	
	int32 PosesChecked;
	int32 InnerAABBsChecked;
	int32 InnerAABBsPassed;
	int32 OuterAABBsChecked;
	int32 OuterAABBsPassed;
	int32 AveragePosesCheckedCounter;
	int32 AveragePosesChecked;
	int32 PosesCheckedMax;
	int32 PosesCheckedMin;
#endif

public:
	FAnimNode_MSMotionMatching();
	virtual ~FAnimNode_MSMotionMatching() override;

	//FAnimNode_AssetPlayerBase interface
	virtual float GetCurrentAssetTime() const override;
	virtual float GetAccumulatedTime() const override;
	virtual float GetCurrentAssetTimePlayRateAdjusted() const override;
	virtual float GetCurrentAssetLength() const override;
	virtual UAnimationAsset* GetAnimAsset() const override;
	//End of FAnimNode_AssetPlayerBase interface
	

	// FAnimNode_Base interface
	virtual void Initialize_AnyThread(const FAnimationInitializeContext& Context) override;
	virtual void CacheBones_AnyThread(const FAnimationCacheBonesContext& Context) override;
	virtual void UpdateAssetPlayer(const FAnimationUpdateContext& Context) override;
	virtual void Evaluate_AnyThread(FPoseContext& Output) override;
	virtual void GatherDebugData(FNodeDebugData& DebugData) override;
	// End of FAnimNode_Base interface

private:
	void InitializeWithPoseRecorder(const FAnimationUpdateContext& Context);
	void InitializeMatchedTransition(const FAnimationUpdateContext& Context);
	void UpdateMotionMatchingState(const float DeltaTime, const FAnimationUpdateContext& Context);
	void UpdateMotionMatching(const float DeltaTime, const FAnimationUpdateContext& Context);
	void ComputeCurrentPose();
	void ComputeCurrentPose(const TArray<float>* CurrentPoseArray);
	void PoseSearch(const FAnimationUpdateContext& Context);
	void TransitionPoseSearch(const FAnimationUpdateContext& Context);
	bool CheckForcePoseSearch(const UMotionDataAsset* InMotionData) const;
	int32 GetLowestCostPoseId_Transition();
	int32 GetLowestCostPoseId_Standard();
	int32 GetLowestCostPoseId_HighQuality(const float DeltaTime);
	int32 GetLowestCostNextNaturalId(int32 LowestPoseId_LM, float& OutLowestCost, TObjectPtr<const UMotionDataAsset> InMotionData);
	bool NextPoseToleranceTest(const FPoseMotionData& NextPose) const;
	void ApplyTrajectoryBlending();
	bool GenerateCalibrationArray();
	
	void TransitionToPose(const int32 PoseId, const FAnimationUpdateContext& Context, const float TimeOffset = 0.0f);
	void JumpToPose(const int32 PoseIdDatabase, const float TimeOffset = 0.0f);

	TObjectPtr<const UMotionDataAsset> GetMotionData() const;
	TObjectPtr<const UMotionCalibration> GetUserCalibration() const;
	UMirrorDataTable* GetMirrorDataTable() const;
	void CheckValidToEvaluate(const FAnimInstanceProxy* InAnimInstanceProxy);

	float GetMotionPlayLength(const int32 AnimId, const EMotionAnimAssetType AnimType, TObjectPtr<const UMotionDataAsset> InMotionData);

	UAnimSequence* GetAnimAtIndex(const int32 AnimId);
	UAnimSequenceBase* GetPrimaryAnim();
	UAnimSequenceBase* GetPrimaryAnim() const;
	void EvaluateSinglePose(FPoseContext& Output);
	void CreateTickRecordForNode(const FAnimationUpdateContext& Context, float PlayRate);

	void DrawInputArrayDebug(FAnimInstanceProxy* InAnimInstanceProxy);
	void DrawChosenInputArrayDebug(FAnimInstanceProxy* InAnimInstanceProxy);
	void DrawChosenPoseDebug(FAnimInstanceProxy* InAnimInstanceProxy, bool bDrawVelocity);
	void DrawSearchCounts(FAnimInstanceProxy* InAnimInstanceProxy);
	void DrawAnimDebug(FAnimInstanceProxy* InAnimInstanceProxy) const;

	void RecordHistoricalPoseSearch(int32 InPosesSearched);

	void FillCompactPoseAndComponentRefRotations(const FBoneContainer& BoneContainer);
};

